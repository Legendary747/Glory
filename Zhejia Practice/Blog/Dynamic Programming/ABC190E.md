#### Magical Ornament

------

###### Problem Analysis

The first assertion is that every node will be visited exactly **once**, otherwise, the distance (the stones included to form the sequence) is not optimal. 

The gems that are in the sequence $C_1, \ C_2, \ ..., \ C_K$ could be viewed as a graph. Other gems are abstracted as part of the edges connecting the selected gems, contributing to the length of the edge. Therefore, this problem is equivalent to calculating the Hamilton distance of the graph. 

The Hamilton distance of the graph $G \ = \ (V,\ E)$ is calculated via **Dynamic Programming**. The basic idea is that we could divide the vertexes on the graph into two sets: *vertexes on the path or visited* or *vertexes not on the path or unvisited*. The *visited* set is marked by **the last visited vertex** on the path because each path that contains the same set of vertexes may generate different path length with different *last visited vertex*. Therefore is *optimal substructure* on the path given a *last visited vertex*. To calculate the final Hamilton length, we should gradually increase the size of the set *visited*. Finally, to represent the set of the vertex visited, **bitmask** technique is used. 

The State $S[path, \ end]$ could represent the *path* visited with a specific *last visited vertex*. To represent the *path* and *last visited vertex* with bitmask, $path \ = \ \{v_1, \ v_2,\ ..., \  v_n\} \ (n \ \le \ K)$ and $end \ = \ v_i \ (v_i \in \ path)$. Therefore,
$$
S[path, \ end] \ := \ S[\{v_1, \ v_2,\ ..., \  v_n\}, \ v_i] \ (n \ \le K, \ 1 \ \le \ i \ \le n)
$$

To calculate the **State Transformation**, we conside the substructure of the current state: a subset of the *path* visited with the *last visited node* excluded $subpath \ := \ path \ - \ \{v_i\}$ with a *last visited vertex* other then $v_i$: $v_j \ (v_j \ \in \ subpath)$. Therefore, 
$$
S[subpath, \ end'] \ := \ S[\{v1, \ v2, \ ..., \ v_n\} \ - \ \{v_i\}, \ v_j] \  (n \ \le \ K, \ 1 \ \le \ i \ \le \ n, \ 1 \ \le \ j \ \le \ n, \ i \ \ne \ j)
$$
To minimise the value of $S[path, \ end]$, we have to enumerate every vertex in the *path* visited except last visited node, namely *second last visited vertex*. Each vertex selected $v_j$ forms a substructure, which should be minimum. Adding it to the distance between *last visited vertex* $v_i$ and $v_j$ represent the length of the path that we, after visiting $v_j$ (*second last visited vertex*), visited $v_i$ (*last visited vertex*). After emumerating all the *second last visited vertex* $v_j$, we assign the length generated by the $v_j$ with **the minimum length of the whole *path*** (not *subpath*) to $S[path, \ end]$. The length is optimal for the State $S[path, \ end]$.
$$
S[\{v_1, \ v_2,\ ..., \  v_n\}, \ v_i] \ = \ \min_j\{S[\{v1, \ v2, \ ..., \ v_n\} \ - \ \{v_i\}, \ v_j] \ + \ distance(v_i, \ v_j)\} \newline (n \ \le \ K, \ 1 \ \le \ i \ \le \ n, \ 1 \ \le \ j \ \le \ n, \ i \ \ne \ j)
$$

When *path* contains all vertexes in the graph, *the last visited vertex* that has the minimum length is the Hamilton distance, which means
$$
Length_{Hamilton} \ = \ \min_k\{S[\{v_1, \ v_2, \ ..., \ v_K\}, \ v_k\} \ (1 \ \le \ k \ \le \ K)
$$

------

###### Implementation

To implement $S[path, \ end]$, **bitmask** technique should be used to represent the set. Each vertex is corresponding to a bit in a binary integer and the vertex is indexed by the index of the bit. Therefore, $path \ = \ (b_{K-1}...b_1b_0)_2$. If $b_i \ = \ 1 \ (0 \ \le \ i \ < \ K)$, the vertex $v_i$ is in the set *path*. Therefore, 
$$
S[path, \ end] \ := \ S[(b_{K-1}...b_1b_0)_2, \ i] \ (0 \ \le \ i \ < \ K, \ b_i \ = \ 1)
$$
Define $n \ = \ (b_{K-1}...b_1b_0)_2 \ (0 \ \le \ n \ < \ 2^K)$, to make sure that $v_i$ is in *path*, we could set the condition that $(n  \ >> \ i) \ \land \ 1 \ = \ 1$, then 
$$
S[path, \ end] \ := S[n, \ i] \ (n \ = \ (b_{K-1}...b_1b_0)_2, \ 0 \ \le \ i \ < \ K, \ (n  \ >> \ i) \ \land \ 1 \ = \ 1)
$$
To rewrite *State Transformation Formula*, which requires to calculate the subset of *path* without *last visited vertex*, we have to the assign 0 the bit corresponding to *last visited vertex*, which is $n \ \oplus \ (1 \ << \ i)$.  Then we iterate all the bits in the number representing the *subpath* that are 1. 
$$
S[n, \ i] \ = \ \min_j\{S[n \ \oplus \ (1 \ << \ i), \ j] \ + \ distance(i, \ j)\} \newline (0 \ \le \ j \ < K, \ (n >> j) \ \land \ 1 \ = \ 1)
$$
The result therefore is
$$
Length_{Hamilton} \ = \ \min_k\{S[2^K \ - \ 1, \ k]\} \ (0 \ \le \ k \ < \ K)
$$

------

###### Code Review

The first step of implementing the *Hamilton Algorithm* is to iterate over all the subsets of a set containing $K$ vertexes. One further thing to notice is that when the set only contains only element, the state should be 0, which is equivalent to $\exist i \ (0 \ \le \ i \ < \ K) \ n \ \equiv \ (1 \ << \ i) \ \implies \ S[n, \ i] \ = \ 0$, which could be implemented as 

```java
for (int i = 0; i < K; i++) graphs[1 << i][i] = 0;
```

Define variable $mask$ to represent *path*, and `graphs` to represent state, each subset of all vertexes, the iterating process could be written as

```java
for (int mask = 1; mask < (1 << K); mask++)
```

To find all the bits that is equal to 1 in `mask`, we have to check $(n  \ >> \ i) \ \land \ 1 \ = \ 1$, which could be implemented as 

```java
for (int i = 0; i < K; i++) if ((mask & (1 << i)) != 0)
```

To implement the *State Transformation Formula* $ S[n, \ i] \ = \ \min_j\{S[n \ \oplus \ (1 \ << \ i), \ j] \ + \ distance(i, \ j)\}$, 

```java
for (int j = 0; j < K; j++) if ((mask & (1 << j)) != 0)
            graphs[mask][i] = Math.min(graphs[mask][i], graphs[mask ^ (1 << i)][j] +                                         distance[Math.min(j, i)][Math.max(j, i)]);
```

Finally, when *path* contains all vertexes, we could implement $\min_k\{S[2^K \ - \ 1, \ k]\}$ via

```java
long best = Long.MAX_VALUE;
for (int i = 0; i < K; i++)
            best = Math.min(best, graphs[(1 << K) - 1][i]);
```
